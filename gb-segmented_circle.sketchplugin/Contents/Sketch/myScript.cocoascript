
var doc, pi, segs, idealsegs, thickness, pArray, def, scrollOrigin, zoomValue, sv

var onRun = function(context) {
  // Global variables
  doc = context.document
  pi = Math.PI
  r = 100
  segs = idealsegs = 6
  thickness = 20
  pArray = []
  def = [NSUserDefaults standardUserDefaults]
  sv = getSkVer()
  //actual functions
  start(context)
}

var start = function(context){
    alert("starting app", "Test")
    var key = "gb_segCircle"
    var sc = [def objectForKey:key]
    if(sc == nil) {sc = r + "," + segs + "," + thickness} //retrieve value from defaults, if none set
    var sInput = [doc askForUserInput:"radius , number of segments , [thickness]" + "\n" + "(Leave Thickness empty to create unfilled line segments)" initialValue:sc]

    r =     parseInt(sInput.split(",")[0])
    segs =  parseInt(sInput.split(",")[1])
    segs =  Math.max(Math.round(segs),3)

    thickness = parseInt(sInput.split(",")[2])
    if(thickness){
        thickness = Math.min(thickness, r)
        [def setObject:(r + "," + segs + "," + thickness) forKey:key]//set defaults to this value
        segmentCircle(r, segs, thickness)
    } else {
        [def setObject:(r + "," + segs) forKey:key]//set defaults to this value
        segmentCircle(r, segs, 1)
    }
    //alert(computeBezierArc(pi/2, 0, 100), "arc test")//alert = function(sText, sTitle)
    //varSegmentCircle([50,30,20])
    //alert(preProcSeg([50,30,10,10]),"Preprocessed segments â†’ anchor angles:")
    varSegmentCircle(100, [40,30,20,10,5,2,1,0.5], 1)//debug
    //dashedCircle(100, 80, 40, 1)//debug
}

var segmentCircle = function(rCirc, numSegs, nThick){
  var angSeg = 2 * pi / numSegs

  var gr = doc.currentPage().addLayerOfType("group")
  gr.setName("Segments Circle")

  for(var i = 0; i < numSegs; i++){
    var path = NSBezierPath.bezierPath()
    //build each of the segments

    var aPts = computeLargeBezierArc(angSeg * i, angSeg * (i + 1), rCirc)
    var nP = aPts.length
    //alert(aSegments[i] + ": " + (aSegs[i]) + " to " + (aSegs[i + 1]),"Calculating segment out")
    for(var j = 0; j < nP; j++){
      if(j == 0) {[path moveToPoint:NSMakePoint(aPts[0].aBeg[0], aPts[0].aBeg[1])]}
      [path curveToPoint:NSMakePoint(aPts[j].aEnd[0], aPts[j].aEnd[1]) controlPoint1:NSMakePoint(aPts[j].cPt1[0], aPts[j].cPt1[1]) controlPoint2:NSMakePoint(aPts[j].cPt2[0], aPts[j].cPt2[1])]
    }

    if (nThick > 1) {
      var rIn = rCirc - nThick
      var aPt2 = computeLargeBezierArc(angSeg * (i + 1), angSeg * i, rIn)
      n2 = aPt2.length
      for(var k = 0; k < n2; k++){
        if(k == 0) {[path lineToPoint:NSMakePoint(aPt2[0].aBeg[0], aPt2[0].aBeg[1])]}
        [path curveToPoint:NSMakePoint(aPt2[k].aEnd[0], aPt2[k].aEnd[1]) controlPoint1:NSMakePoint(aPt2[k].cPt1[0], aPt2[k].cPt1[1]) controlPoint2:NSMakePoint(aPt2[k].cPt2[0], aPt2[k].cPt2[1])]
      }
      [path closePath]
    }

    var shape = MSShapeGroup.shapeWithBezierPath(path);
    if (nThick > 1) {styleShapeArea(shape)} else {styleShape(shape)}
    shape.setName("Segment " + i)
    gr.addLayers([shape]);
  }
  placeLayer(gr)
}

var varSegmentCircle = function(rCirc, aSegments, nThick){
  var numSegs = aSegments.length
  var aSegs = preProcSeg(aSegments)

  var gr = doc.currentPage().addLayerOfType("group")
  gr.setName("Variable segments donut")
  for(var i = 0; i < numSegs; i++){
    var path = NSBezierPath.bezierPath()
    //build each of the segments

    var aPts = computeLargeBezierArc(aSegs[i], aSegs[i + 1], rCirc)
    var nP = aPts.length
    //alert(aSegments[i] + ": " + (aSegs[i]) + " to " + (aSegs[i + 1]),"Calculating segment out")
    for(var j = 0; j < nP; j++){
      if(j == 0) {[path moveToPoint:NSMakePoint(aPts[0].aBeg[0], aPts[0].aBeg[1])]}
      [path curveToPoint:NSMakePoint(aPts[j].aEnd[0], aPts[j].aEnd[1]) controlPoint1:NSMakePoint(aPts[j].cPt1[0], aPts[j].cPt1[1]) controlPoint2:NSMakePoint(aPts[j].cPt2[0], aPts[j].cPt2[1])]
    }

    if (nThick > 1) {
      var rIn = rCirc - nThick
      var aPt2 = computeLargeBezierArc(aSegs[i + 1], aSegs[i], rIn)
      n2 = aPt2.length
      for(var k = 0; k < n2; k++){
        if(k == 0) {[path lineToPoint:NSMakePoint(aPt2[0].aBeg[0], aPt2[0].aBeg[1])]}
        [path curveToPoint:NSMakePoint(aPt2[k].aEnd[0], aPt2[k].aEnd[1]) controlPoint1:NSMakePoint(aPt2[k].cPt1[0], aPt2[k].cPt1[1]) controlPoint2:NSMakePoint(aPt2[k].cPt2[0], aPt2[k].cPt2[1])]
      }
      [path closePath]
    }

    var shape = MSShapeGroup.shapeWithBezierPath(path);
    if (nThick > 1) {styleShapeArea(shape)} else {styleShape(shape)}
    shape.setName("Segment " + (aSegments[i]))
    gr.addLayers([shape]);
  }
  placeLayer(gr)
}

var ticksCircle = function(rCirc, numMin, numMaj, nThickMin, nThickMaj) {
  //creates minor and major tickmarks along a circle
}

var dashedCircle = function(rCirc, lDash, lGap, nThick) {
  //creates dashing along the circle circumference
  //optmize dash/gap size for even dashes
  var cf = 2 * pi * rCirc
  var lSeg = lGap + lDash
  var numSegs = Math.max(4, Math.floor(cf / lSeg))
  var angSeg = 2 * pi / numSegs
  var angDash = angSeg * lDash / lSeg
  var angGap = angSeg - angDash

  var gr = doc.currentPage().addLayerOfType("group")
  gr.setName("Dashed Circle")
  for(var i = 0; i < numSegs; i++){
    var path = NSBezierPath.bezierPath()

    //build each of the segments
    var aPts = computeLargeBezierArc(angSeg * i, (angSeg * i) + angDash, rCirc)
    var nP = aPts.length //just in case curve needs to be split up into multiple segments for length
    for(var j = 0; j < nP; j++){
      if(j == 0) {[path moveToPoint:NSMakePoint(aPts[0].aBeg[0], aPts[0].aBeg[1])]}
      [path curveToPoint:NSMakePoint(aPts[j].aEnd[0], aPts[j].aEnd[1]) controlPoint1:NSMakePoint(aPts[j].cPt1[0], aPts[j].cPt1[1]) controlPoint2:NSMakePoint(aPts[j].cPt2[0], aPts[j].cPt2[1])]
    }
    if (nThick > 1) {
        var rIn = r - nThick
        var aPt2 = computeLargeBezierArc((angSeg * i) + angDash, angSeg * i, rIn)
        n2 = aPt2.length
        for(var k = 0; k < n2; k++){
          if(k == 0) {[path lineToPoint:NSMakePoint(aPt2[0].aBeg[0], aPt2[0].aBeg[1])]}
          [path curveToPoint:NSMakePoint(aPt2[k].aEnd[0], aPt2[k].aEnd[1]) controlPoint1:NSMakePoint(aPt2[k].cPt1[0], aPt2[k].cPt1[1]) controlPoint2:NSMakePoint(aPt2[k].cPt2[0], aPt2[k].cPt2[1])]
        }
      [path closePath]
    }

    var shape = MSShapeGroup.shapeWithBezierPath(path);
    if (nThick > 1) {styleShapeArea(shape)} else {styleShape(shape)}
    shape.setName("Dash " + i)
    gr.addLayers([shape])

  }
  placeLayer(gr)
}


//*********** util functions ***********//

var computeBezierArc = function(angStart, angEnd, rSeg){
  //compute single segment with start and end angle and radius
  var lSeg = angEnd - angStart
  var lCpHandle = rSeg * 4 / 3 * (Math.tan(lSeg / 4))
  //alert("length of cp handle is " + lCpHandle, "Test")
  var aGeomFactor = [Math.cos(angStart - pi/2), Math.sin(angStart - pi/2)]
  var pAnchor1 = 		[rd2dec(aGeomFactor[0] * rSeg), rd2dec(aGeomFactor[1] * rSeg)]
  var pLe1 =        [pAnchor1[0] - rd2dec(aGeomFactor[1] * lCpHandle), pAnchor1[1] + rd2dec(aGeomFactor[0] * lCpHandle)]
  var pRi1 =        [pAnchor1[0] + rd2dec(aGeomFactor[1] * lCpHandle), pAnchor1[1] - rd2dec(aGeomFactor[0] * lCpHandle)]
  //alert("GFact1 is " + aGeomFactor, "Test")
  aGeomFactor =     [Math.cos(angEnd - pi/2), Math.sin(angEnd - pi/2)]
  var pAnchor2 =    [rd2dec(aGeomFactor[0] * rSeg), rd2dec(aGeomFactor[1] * rSeg)]
  var pLe2 =        [pAnchor2[0] - rd2dec(aGeomFactor[1] * lCpHandle), pAnchor2[1] + rd2dec(aGeomFactor[0] * lCpHandle)]
  var pRi2 =        [pAnchor2[0] + rd2dec(aGeomFactor[1] * lCpHandle), pAnchor2[1] - rd2dec(aGeomFactor[0] * lCpHandle)]

  return {aBeg:pAnchor1, cPt1:pLe1, cPt2:pRi2, aEnd:pAnchor2}
}

var computeLargeBezierArc = function(angStart, angEnd, rSeg){
  //return path points for n arcs > ideal segments
  var angIdeal = 2 * pi / idealsegs
  var nIdeal = Math.trunc((angEnd - angStart) / angIdeal)
  //var aRem = (angEnd - angStart) % angIdeal
  if(nIdeal < 0){angIdeal *= (-1);nIdeal *= (-1);}//CCW
  var aPts = []
  var angCurr = angStart
  for(i = 0; i < nIdeal + 1; i++){
    if(i < nIdeal) {
      aPts.push(computeBezierArc(angCurr, angCurr + angIdeal, rSeg))//fill with ideal sized segments
      angCurr += angIdeal
    } else {
      if(Math.abs(angEnd - angCurr) > 0.00001){ aPts.push(computeBezierArc(angCurr, angEnd, rSeg))} //end with smaller sized remainder
    }
  }
  return aPts;
}

var rd2dec = function(num) {
    return Math.round(num * 100) / 100;
}

var preProcSeg = function(aSegments){
  //normalize to 6.28
  var aSegs = [0]
  var total = 0;
  var n = aSegments.length;
  var i = n;
  while (i--) {total += aSegments[i]}
  var factor = 2 * pi / total
  for (i=1; i<=n; i++) {aSegs.push(aSegs[i-1] + (aSegments[i-1] * factor))}
  aSegs[aSegs.length - 1] = 6.28
  return aSegs
}

var alert = function(sText, sTitle) {
	[[NSApplication sharedApplication] displayDialog:sText withTitle:sTitle];
    //doc.showMessage(sText)
}

var getViewF = function(){
    //get position with view.postion.x etc and size with view.size.width etc.
    view = [doc currentView];
    return [view frame];
}

var styleShape = function(shapeGr){
    var border = shapeGr.style().borders().addNewStylePart();
    border.color = MSColor.colorWithSVGString("#000066");
    border.thickness = 2;
    //border.position = 1;
}

var styleShapeArea = function(shapeGr){
    var fill = shapeGr.style().fills().addNewStylePart();
    fill.color = MSColor.colorWithSVGString("#cccccc");
    var border = shapeGr.style().borders().addNewStylePart();
    border.color = MSColor.colorWithSVGString("#f0f0f0");
    border.thickness = 1;
    //border.position = 1;
}

var placeLayer = function(lyr){
    var rL = lyr.rect();
    var v = getViewF();
    var so = [doc scrollOrigin];
    var zv = [doc zoomValue]
    var vX = (v.size.width / 2 - so.x) / zv;
    var vY = (v.size.height / 2 - so.y) / zv;
    rL.origin.x = vX
    rL.origin.y = vY
    lyr.setRect(rL)
    if(sv <= 34400) {
      lyr.resizeRoot(true)
    } else {
      lyr.resizeToFitChildrenWithOption(0)
    }
}

var getSkVer = function() {
	var v = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleShortVersionString"]
	var v2 = v.split('.').join("")
	do {
		v2 = v2 + "0"
	} while(v2.length <= 4)
	return (Number(v2) + 0)
}

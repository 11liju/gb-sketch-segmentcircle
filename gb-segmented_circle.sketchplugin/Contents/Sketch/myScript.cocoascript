
var doc, pi, segs, idealsegs, r, thickness, pArray, def, scrollOrigin, zoomValue, sv

var onRun = function(context) {
  // Global variables
  doc = context.document
  pi = Math.PI
  r = 100
  segs = idealsegs = 6
  thickness = 20
  pArray = []
  def = [NSUserDefaults standardUserDefaults]
  sv = getSkVer()
  //actual functions
  start(context)
}

var start = function(context){
    alert("starting app", "Test")
    var key = "gb_segCircle"
    var sc = [def objectForKey:key]
    if(sc == nil) {sc = r + "," + segs + "," + thickness} //retrieve value from defaults, if none set
    var sInput = [doc askForUserInput:"radius , number of segments , [thickness]" + "\n" + "(Leave Thickness empty to create unfilled line segments)" initialValue:sc]

    r =     parseInt(sInput.split(",")[0])
    segs =  parseInt(sInput.split(",")[1])
    segs =  Math.max(Math.round(segs),3)

    thickness = parseInt(sInput.split(",")[2])
    if(thickness){
        thickness = Math.min(thickness, r)
        [def setObject:(r + "," + segs + "," + thickness) forKey:key]//set defaults to this value
        multiSegmentDonut(segs, thickness)
    } else {
        [def setObject:(r + "," + segs) forKey:key]//set defaults to this value
        multiSegmentCircle(segs)
    }
    //alert(computeBezierArc(pi/2, 0, 100), "arc test")//alert = function(sText, sTitle)
    //varSegmentCircle([50,30,20])
    //alert(preProcSeg([50,30,10,10]),"Preprocessed segments → anchor angles:")
    //varSegmentDonut([40,30,20,10,5,2,1,0.5], 50)//debug
    dashedCircle(100, 40, 20, 1)//debug
}

var multiSegmentCircle = function(numSegs){
  var angSeg = 2 * pi / numSegs
  var path = NSBezierPath.bezierPath()

  for(var i = 0; i < numSegs; i++){
    var aPts = computeBezierArc(i * angSeg, (i+1) * angSeg, r)
    //alert(aPts, "arc test")//alert = function(sText, sTitle)
    if(i == 0) {path.moveToPoint(NSMakePoint(aPts.aBeg[0], aPts.aBeg[1]))}
    [path curveToPoint:NSMakePoint(aPts.aEnd[0], aPts.aEnd[1]) controlPoint1:NSMakePoint(aPts.cPt1[0], aPts.cPt1[1]) controlPoint2:NSMakePoint(aPts.cPt2[0], aPts.cPt2[1])]
  }

  var shape = MSShapeGroup.shapeWithBezierPath(path);
  shape.setName("Segments")
  var gr = doc.currentPage().addLayerOfType("group")
  //[gr setFrame:NSMakeRect(-r, -r, r*2, r*2)]
  gr.setName("Segment circle (line)")
  styleShape(shape)
  gr.addLayers([shape])

  placeLayer(gr)
}

var varSegmentCircle = function(aSegments){
  var numSegs = aSegments.length
  var aSegs = preProcSeg(aSegments)
  //alert(aSegments + " → " + aSegs,"Test")

  var gr = doc.currentPage().addLayerOfType("group")
  gr.setName("Variable segments circle")
  for(var i = 0; i < numSegs; i++){
    //build each of the segments
    //alert("from " + aSegs[i] + " to " + aSegs[i + 1], "Segment being computed: #" + i)
    var path = NSBezierPath.bezierPath()
    var aPts = computeLargeBezierArc(aSegs[i], aSegs[i + 1], r)
    for(var j = 0; j < aPts.length; j++){
      if(j == 0) {path.moveToPoint(NSMakePoint(aPts[0].aBeg[0], aPts[0].aBeg[1]))}
      [path curveToPoint:NSMakePoint(aPts[j].aEnd[0], aPts[j].aEnd[1]) controlPoint1:NSMakePoint(aPts[j].cPt1[0], aPts[j].cPt1[1]) controlPoint2:NSMakePoint(aPts[j].cPt2[0], aPts[j].cPt2[1])]
    }
    var shape = MSShapeGroup.shapeWithBezierPath(path);
    styleShape(shape)
    shape.setName("Segment " + (aSegments[i]))
    gr.addLayers([shape]);
  }
  placeLayer(gr)
}

var varSegmentDonut = function(aSegments, nThick){
  var numSegs = aSegments.length
  var aSegs = preProcSeg(aSegments)
  //alert(aSegments + " → " + aSegs,"Test")

  var gr = doc.currentPage().addLayerOfType("group")
  gr.setName("Variable segments donut")
  for(var i = 0; i < numSegs; i++){
    var path = NSBezierPath.bezierPath()
    //build each of the segments

    var aPts = computeLargeBezierArc(aSegs[i], aSegs[i + 1], r)
    var nP = aPts.length
    //alert(aSegments[i] + ": " + (aSegs[i]) + " to " + (aSegs[i + 1]),"Calculating segment out")
    for(var j = 0; j < nP; j++){
      if(j == 0) {[path moveToPoint:NSMakePoint(aPts[0].aBeg[0], aPts[0].aBeg[1])]}
      [path curveToPoint:NSMakePoint(aPts[j].aEnd[0], aPts[j].aEnd[1]) controlPoint1:NSMakePoint(aPts[j].cPt1[0], aPts[j].cPt1[1]) controlPoint2:NSMakePoint(aPts[j].cPt2[0], aPts[j].cPt2[1])]
    }

    var rIn = r - nThick
    var aPt2 = computeLargeBezierArc(aSegs[i + 1], aSegs[i], rIn)
    n2 = aPt2.length
    //alert(aSegments[i] + ": " + (aSegs[i + 1]) + " to " + (aSegs[i]),"Calculating segment back")
    for(var k = 0; k < n2; k++){
      if(k == 0) {[path lineToPoint:NSMakePoint(aPt2[0].aBeg[0], aPt2[0].aBeg[1])]}
      [path curveToPoint:NSMakePoint(aPt2[k].aEnd[0], aPt2[k].aEnd[1]) controlPoint1:NSMakePoint(aPt2[k].cPt1[0], aPt2[k].cPt1[1]) controlPoint2:NSMakePoint(aPt2[k].cPt2[0], aPt2[k].cPt2[1])]
    }

    [path closePath]
    var shape = MSShapeGroup.shapeWithBezierPath(path);
    styleShapeArea(shape)
    shape.setName("Segment " + (aSegments[i]))
    gr.addLayers([shape]);
  }
  placeLayer(gr)
}

var multiSegmentDonut = function(numSegs, nThick){
    //compute ideal cp handle length
	pArray = []
    var rI = r - nThick
    var lSeg = 2 * pi / numSegs
    var lCpHandle = r * 4 / 3 * (Math.tan(pi / (2 * numSegs)))
    var lCpHandleI = rI * 4 / 3 * (Math.tan(pi / (2 * numSegs)))
    //alert("length of cp handle is " + lCpHandle, "Test")
    for(var i = -1; i <= numSegs; i++){
    	var aGeomFactor = 	[Math.cos(lSeg * i - pi/2), Math.sin(lSeg * i - pi/2)]
      if(i == 0){alert("GFact1 is " + aGeomFactor, "Test")}//test
    	var pAnchor = 		[rd2dec(aGeomFactor[0] * r), rd2dec(aGeomFactor[1] * r)]
    var pAnchorI =      [rd2dec(aGeomFactor[0] * rI), rd2dec(aGeomFactor[1] * rI)]
    	var pLe =			[pAnchor[0] - rd2dec(aGeomFactor[1] * lCpHandle), pAnchor[1] + rd2dec(aGeomFactor[0] * lCpHandle)]
    	var pRi =			[pAnchor[0] + rd2dec(aGeomFactor[1] * lCpHandle), pAnchor[1] - rd2dec(aGeomFactor[0] * lCpHandle)]
    var pLeI =			[pAnchorI[0] - rd2dec(aGeomFactor[1] * lCpHandleI), pAnchorI[1] + rd2dec(aGeomFactor[0] * lCpHandleI)]
    	var pRiI =			[pAnchorI[0] + rd2dec(aGeomFactor[1] * lCpHandleI), pAnchorI[1] - rd2dec(aGeomFactor[0] * lCpHandleI)]
    	pArray.push({anchor:pAnchor, left:pLe, right:pRi, anchorI:pAnchorI, leftI:pLeI, rightI:pRiI})
    }

	  var gr = doc.currentPage().addLayerOfType("group")
    gr.setName("Segment circle")

    for(var j = 0; j < numSegs; j++){
        var i = j + 1
		    var path = NSBezierPath.bezierPath();
        [path moveToPoint:NSMakePoint(pArray[i].anchor[0], pArray[i].anchor[1])];
    		[path curveToPoint:NSMakePoint(pArray[i+1].anchor[0], pArray[i+1].anchor[1]) controlPoint1:NSMakePoint(pArray[i].left[0], pArray[i].left[1]) controlPoint2:NSMakePoint(pArray[i+1].right[0], pArray[i+1].right[1])]
        [path lineToPoint:NSMakePoint(pArray[i+1].anchorI[0], pArray[i+1].anchorI[1])];
        [path curveToPoint:NSMakePoint(pArray[i].anchorI[0], pArray[i].anchorI[1]) controlPoint1:NSMakePoint(pArray[i+1].rightI[0], pArray[i+1].rightI[1]) controlPoint2:NSMakePoint(pArray[i].leftI[0], pArray[i].leftI[1])]
        [path lineToPoint:NSMakePoint(pArray[i].anchor[0], pArray[i].anchor[1])];
        [path closePath]

        var shape = MSShapeGroup.shapeWithBezierPath(path);
        styleShape(shape)
        shape.setName("Segment " + i)
        //add to group
        gr.addLayers([shape]);
	}

  placeLayer(gr)
}

var ticksCircle = function(rCirc, numMin, numMaj, nThickMin, nThickMaj) {
  //creates minor and major tickmarks along a circle
}

var dashedCircle = function(rCirc, lDash, lGap, nThick) {
  //creates dashing along the circle circumference
  //optimizes lengths of dashes and gaps to evenly fit the circle
  //if length to large for circle 4 dashes/gaps will be created based on prop dash/gaps

  //find the best fitting dash/gap size
  var cf = 2 * pi * rCirc
  var lSeg = lGap + lDash
  var numSegs = Math.max(4, Math.floor(cf / lSeg))
  var angSeg = 2 * pi / numSegs
  var angDash = angSeg * lDash / lSeg
  var angGap = angSeg - angDash
  alert("Dashed circle: " + numSegs + " recommended segments with dash/gap: " + angDash + "/" + angGap, "Dashed Circle")

  var gr = doc.currentPage().addLayerOfType("group")
  gr.setName("Dashed Circle")
  for(var i = 0; i < numSegs; i++){
    var path = NSBezierPath.bezierPath()

    //build each of the segments
    var aPts = computeLargeBezierArc(angSeg * i, (angSeg * i) + angDash, rCirc)
    var nP = aPts.length //just in case curve needs to be split up into multiple segments for length
    alert( "From: " + angSeg * i + " to: " + ((angSeg * i) + angDash) + "\n" + nP + " curve(s).", "Dashed circle" )
    alert( aPts, "Dashed circle points array" )
    for(var j = 0; j < nP; j++){
      if(j == 0) {[path moveToPoint:NSMakePoint(aPts[0].aBeg[0], aPts[0].aBeg[1])]}
      [path curveToPoint:NSMakePoint(aPts[j].aEnd[0], aPts[j].aEnd[1]) controlPoint1:NSMakePoint(aPts[j].cPt1[0], aPts[j].cPt1[1]) controlPoint2:NSMakePoint(aPts[j].cPt2[0], aPts[j].cPt2[1])]
    }
    if (nThick > 1) {
      //   var rIn = r - nThick
      //   var aPt2 = computeLargeBezierArc(aSegs[i + 1], aSegs[i], rIn)
      //   n2 = aPt2.length
      //   //alert(aSegments[i] + ": " + (aSegs[i + 1]) + " to " + (aSegs[i]),"Calculating segment back")
      //   for(var k = 0; k < n2; k++){
      //     if(k == 0) {[path lineToPoint:NSMakePoint(aPt2[0].aBeg[0], aPt2[0].aBeg[1])]}
      //     [path curveToPoint:NSMakePoint(aPt2[k].aEnd[0], aPt2[k].aEnd[1]) controlPoint1:NSMakePoint(aPt2[k].cPt1[0], aPt2[k].cPt1[1]) controlPoint2:NSMakePoint(aPt2[k].cPt2[0], aPt2[k].cPt2[1])]
      //   }
      [path closePath] //only if we created an area
    }

    var shape = MSShapeGroup.shapeWithBezierPath(path);
    styleShapeArea(shape)
    shape.setName("Dash " + i)
    gr.addLayers([shape])

  }
  placeLayer(gr)
}


//*********** util functions ***********//

var computeBezierArc = function(angStart, angEnd, rSeg){
  //compute single segment with start and end angle and radius
  var lSeg = angEnd - angStart
  var lCpHandle = rSeg * 4 / 3 * (Math.tan(lSeg / 4))
  //alert("length of cp handle is " + lCpHandle, "Test")
  var aGeomFactor = [Math.cos(angStart - pi/2), Math.sin(angStart - pi/2)]
  var pAnchor1 = 		[rd2dec(aGeomFactor[0] * rSeg), rd2dec(aGeomFactor[1] * rSeg)]
  var pLe1 =        [pAnchor1[0] - rd2dec(aGeomFactor[1] * lCpHandle), pAnchor1[1] + rd2dec(aGeomFactor[0] * lCpHandle)]
  var pRi1 =        [pAnchor1[0] + rd2dec(aGeomFactor[1] * lCpHandle), pAnchor1[1] - rd2dec(aGeomFactor[0] * lCpHandle)]
  //alert("GFact1 is " + aGeomFactor, "Test")
  aGeomFactor =     [Math.cos(angEnd - pi/2), Math.sin(angEnd - pi/2)]
  var pAnchor2 =    [rd2dec(aGeomFactor[0] * rSeg), rd2dec(aGeomFactor[1] * rSeg)]
  var pLe2 =        [pAnchor2[0] - rd2dec(aGeomFactor[1] * lCpHandle), pAnchor2[1] + rd2dec(aGeomFactor[0] * lCpHandle)]
  var pRi2 =        [pAnchor2[0] + rd2dec(aGeomFactor[1] * lCpHandle), pAnchor2[1] - rd2dec(aGeomFactor[0] * lCpHandle)]

  return {aBeg:pAnchor1, cPt1:pLe1, cPt2:pRi2, aEnd:pAnchor2}
}

var computeLargeBezierArc = function(angStart, angEnd, rSeg){
  //return path points for n arcs > ideal segments
  var angIdeal = 2 * pi / idealsegs
  var nIdeal = Math.trunc((angEnd - angStart) / angIdeal)
  //var aRem = (angEnd - angStart) % angIdeal
  if(nIdeal < 0){angIdeal *= (-1);nIdeal *= (-1);}//CCW
  var aPts = []
  var angCurr = angStart
  for(i = 0; i < nIdeal + 1; i++){
    if(i < nIdeal) {
      aPts.push(computeBezierArc(angCurr, angCurr + angIdeal, rSeg))//fill with ideal sized segments
      angCurr += angIdeal
    } else {
      if(Math.abs(angEnd - angCurr) > 0.00001){ aPts.push(computeBezierArc(angCurr, angEnd, rSeg))} //end with smaller sized remainder
    }
  }
  return aPts;
}

var rd2dec = function(num) {
    return Math.round(num * 100) / 100;
}

var preProcSeg = function(aSegments){
  //normalize to 6.28
  var aSegs = [0]
  var total = 0;
  var n = aSegments.length;
  var i = n;
  while (i--) {total += aSegments[i]}
  var factor = 2 * pi / total
  for (i=1; i<=n; i++) {aSegs.push(aSegs[i-1] + (aSegments[i-1] * factor))}
  aSegs[aSegs.length - 1] = 6.28
  return aSegs
}

var alert = function(sText, sTitle) {
	[[NSApplication sharedApplication] displayDialog:sText withTitle:sTitle];
    //doc.showMessage(sText)
}

var getViewF = function(){
    //get position with view.postion.x etc and size with view.size.width etc.
    view = [doc currentView];
    return [view frame];
}

var styleShape = function(shapeGr){
    var border = shapeGr.style().borders().addNewStylePart();
    border.color = MSColor.colorWithSVGString("#000066");
    border.thickness = 2;
    //border.position = 1;
}

var styleShapeArea = function(shapeGr){
    var fill = shapeGr.style().fills().addNewStylePart();
    fill.color = MSColor.colorWithSVGString("#cccccc");
    var border = shapeGr.style().borders().addNewStylePart();
    border.color = MSColor.colorWithSVGString("#f0f0f0");
    border.thickness = 1;
    //border.position = 1;
}

var placeLayer = function(lyr){
    var rL = lyr.rect();
    var v = getViewF();
    var so = [doc scrollOrigin];
    var zv = [doc zoomValue]
    var vX = (v.size.width / 2 - so.x) / zv;
    var vY = (v.size.height / 2 - so.y) / zv;
    rL.origin.x = vX
    rL.origin.y = vY
    lyr.setRect(rL)
    if(sv <= 34400) {
      lyr.resizeRoot(true)
    } else {
      lyr.resizeToFitChildrenWithOption(0)
    }
}

var getSkVer = function() {
	var v = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleShortVersionString"]
	var v2 = v.split('.').join("")
	do {
		v2 = v2 + "0"
	} while(v2.length <= 4)
	return (Number(v2) + 0)
}

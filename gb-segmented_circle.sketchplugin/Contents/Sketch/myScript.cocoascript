var doc, pi, segs, idealsegs, thickness, pArray, def, scrollOrigin, zoomValue, sv

var onRun = function(context) {
  // Global variables
  doc = context.document
  pi = Math.PI
  r = 100
  segs = idealsegs = 6
  thickness = 20
  pArray = []
  def = [NSUserDefaults standardUserDefaults]
  sv = getSkVer()
  //actual functions
  start(context)
}

var start = function(context){
    var key = "gb_segCircle_segm" //retrieve value from defaults, if none set
    var sc = [def objectForKey:key] || [{label: "Outer radius", data:r}, {label: "Number of segments", data:segs}, {label: "Thickness", data:thickness}]
    alert("starting app: " + sc, "Defaults")
    var inp = showDlg(
      "Segment Circle",
      "Input radius, number of segments and thickness (optional). \nIf Thickness is < 2 or left out â†’ rendered as line segments.",
      [{label: "Outer radius", data:sc[0].data}, {label: "Number of segments", data:sc[1].data}, {label: "Thickness", data:sc[2].data}],
      "Create Circle")
    // initialValue:sc]
    r =     parseInt(inp[0])
    segs =  parseInt(inp[1])
    segs =  Math.max(Math.round(segs),3)
    thickness = Math.min(parseInt(inp[2]),r)
    [def setObject:[{label: "Outer radius", data:r}, {label: "Number of segments", data:segs}, {label: "Thickness", data:thickness}] forKey:key]
    segmentCircle(r, segs, thickness)

    //varSegmentCircle([50,30,20])
    varSegmentCircle(100, [40,30,20,10,5,2,1,0.5], 40)//debug
    //dashedCircle(100, 80, 40, 1)//debug
    //ticksCircle(84, 100, 4, 8, 4, 4, 4, 20, pi/2)//debug
}

var segmentCircle = function(rCirc, numSegs, nThick){
  var gr = doc.currentPage().addLayerOfType("group")
  var c = getRnCol()
  gr.setName("Segments circle")

  var angSeg = 2 * pi / numSegs

  for(var i = 0; i < numSegs; i++){
    var shape = makeArcSeg(angSeg * i , angSeg * (i + 1), rCirc, nThick)
    if (nThick > 1) {styleShapeArea(shape, c)} else {styleShape(shape, c)}
    shape.setName("Segment " + (i + 1))
    gr.addLayers([shape]);
  }
  placeLayer(gr)
}

var varSegmentCircle = function(rCirc, aSegments, nThick){
  var numSegs = aSegments.length
  var aSegs = preProcSeg(aSegments)

  var gr = doc.currentPage().addLayerOfType("group")
  gr.setName("Variable segments circle")
  for(var i = 0; i < numSegs; i++){
    var shape = makeArcSeg(aSegs[i], aSegs[i + 1], rCirc, nThick)
    if (nThick > 1) {styleShapeArea(shape,getRnCol())} else {styleShape(shape,getRnCol())}
    shape.setName("Segment " + (aSegments[i]))
    gr.addLayers([shape]);
  }
  placeLayer(gr)
}

var ticksCircle = function(rOutMin, rOutMaj, numMin, numMaj, nStrkMin, nStrkMaj, nThickMin, nThickMaj, angOmit) {
  //creates minor and major tickmarks along a circle minus the cutout angOmit
  var gr = doc.currentPage().addLayerOfType("group")
  var c1 = getRnCol()
  var c2 = getRnCol()
  gr.setName("Tickmarks circle")
  var grMaj = gr.addLayerOfType("group")
  grMaj.setName("Major tickmarks")
  if (numMin > 0){
    var grMin = gr.addLayerOfType("group")
    grMin.setName("Minor tickmarks")
  }

  var angRange = 2 * pi - angOmit
  //alert(angRange,"Range:")
  var cf = angRange * rOutMaj
  var angPx = angRange / Math.round(cf)
  var angDistTick = angRange / ((numMaj - 1) * (numMin + 1))
  var angCor = (angOmit > 0) ? angOmit / 2 + pi / 2 : 0
  for(var i = 0; i < numMaj; i++){
    var a = (i * (numMin + 1)) * angDistTick - angCor
    var shape = makeArcSeg(a - ((nStrkMaj/2) * angPx) , a + ((nStrkMaj/2) * angPx), rOutMaj, nThickMaj)
    if (nThickMaj > 1) {styleShapeArea(shape,c1)} else {styleShape(shape,c1)}
    shape.setName("Tick major " + (i * (numMin + 1)))
    grMaj.addLayers([shape]);

    if(numMin >= 1 && (i < (numMaj - 1))){
      var ub = (i == (numMaj - 2)) ? numMin + 2 : numMin + 1 // last minor tick under the last major one
      for(var j = 0; j < ub; j++){
        var a = ((i * (numMin + 1)) + j) * angDistTick - angCor
        var shape = makeArcSeg(a - ((nStrkMin/2) * angPx) , a + ((nStrkMin/2) * angPx), rOutMin, nThickMin)
        if (nThickMin > 1) {styleShapeArea(shape,c2)} else {styleShape(shape,c2)}
        shape.setName("Tick minor " + (((i * (numMin + 1)) + j) + 0))
        grMin.addLayers([shape]);
      }
    }
  }
  placeLayer(gr)
}

var dashedCircle = function(rCirc, lDash, lGap, nThick) {
  //creates dashing along the circle circumference
  //optmize dash/gap size for even dashes
  var cf = 2 * pi * rCirc
  var lSeg = lGap + lDash
  var numSegs = Math.max(4, Math.floor(cf / lSeg))
  var angSeg = 2 * pi / numSegs
  var angDash = angSeg * lDash / lSeg
  var angGap = angSeg - angDash

  var gr = doc.currentPage().addLayerOfType("group")
  gr.setName("Dashed circle")
  var c = getRnCol()
  for(var i = 0; i < numSegs; i++){
    var shape = makeArcSeg(angSeg * i, (angSeg * i) + angDash, rCirc, nThick)
    if (nThick > 1) {styleShapeArea(shape, c)} else {styleShape(shape, c)}
    shape.setName("Dash " + i)
    gr.addLayers([shape])

  }
  placeLayer(gr)
}


//*********** util functions ***********//

var computeBezierArc = function(angStart, angEnd, rSeg){
  //compute single segment with start and end angle and radius
  var lSeg = angEnd - angStart
  var lCpHandle = rSeg * 4 / 3 * (Math.tan(lSeg / 4))
  //alert("length of cp handle is " + lCpHandle, "Test")
  var aGeomFactor = [Math.cos(angStart - pi/2), Math.sin(angStart - pi/2)]
  var pAnchor1 = 		[rd2dec(aGeomFactor[0] * rSeg), rd2dec(aGeomFactor[1] * rSeg)]
  var pLe1 =        [pAnchor1[0] - rd2dec(aGeomFactor[1] * lCpHandle), pAnchor1[1] + rd2dec(aGeomFactor[0] * lCpHandle)]
  var pRi1 =        [pAnchor1[0] + rd2dec(aGeomFactor[1] * lCpHandle), pAnchor1[1] - rd2dec(aGeomFactor[0] * lCpHandle)]
  //alert("GFact1 is " + aGeomFactor, "Test")
  aGeomFactor =     [Math.cos(angEnd - pi/2), Math.sin(angEnd - pi/2)]
  var pAnchor2 =    [rd2dec(aGeomFactor[0] * rSeg), rd2dec(aGeomFactor[1] * rSeg)]
  var pLe2 =        [pAnchor2[0] - rd2dec(aGeomFactor[1] * lCpHandle), pAnchor2[1] + rd2dec(aGeomFactor[0] * lCpHandle)]
  var pRi2 =        [pAnchor2[0] + rd2dec(aGeomFactor[1] * lCpHandle), pAnchor2[1] - rd2dec(aGeomFactor[0] * lCpHandle)]

  return {aBeg:pAnchor1, cPt1:pLe1, cPt2:pRi2, aEnd:pAnchor2}
}

var computeLargeBezierArc = function(angStart, angEnd, rSeg){
  //return path points for n arcs > ideal segments
  var angIdeal = 2 * pi / idealsegs
  var nIdeal = Math.trunc((angEnd - angStart) / angIdeal)
  //var aRem = (angEnd - angStart) % angIdeal
  if(nIdeal < 0){angIdeal *= (-1);nIdeal *= (-1);}//CCW
  var aPts = []
  var angCurr = angStart
  for(i = 0; i < nIdeal + 1; i++){
    if(i < nIdeal) {
      aPts.push(computeBezierArc(angCurr, angCurr + angIdeal, rSeg))//fill with ideal sized segments
      angCurr += angIdeal
    } else {
      if(Math.abs(angEnd - angCurr) > 0.00001){ aPts.push(computeBezierArc(angCurr, angEnd, rSeg))} //end with smaller sized remainder
    }
  }
  return aPts;
}

var makeArcSeg = function(angStart, angEnd, rSeg, nThick){
  var path = NSBezierPath.bezierPath()
  var aPts = computeLargeBezierArc(angStart, angEnd, rSeg)
  var nP = aPts.length
  for(var j = 0; j < nP; j++){
    if(j == 0) {[path moveToPoint:NSMakePoint(aPts[0].aBeg[0], aPts[0].aBeg[1])]}
    [path curveToPoint:NSMakePoint(aPts[j].aEnd[0], aPts[j].aEnd[1]) controlPoint1:NSMakePoint(aPts[j].cPt1[0], aPts[j].cPt1[1]) controlPoint2:NSMakePoint(aPts[j].cPt2[0], aPts[j].cPt2[1])]
  }
  if (nThick > 1) {
    var rIn = rSeg - nThick
    var aPt2 = computeLargeBezierArc(angEnd, angStart, rIn)
    n2 = aPt2.length
    for(var k = 0; k < n2; k++){
      if(k == 0) {[path lineToPoint:NSMakePoint(aPt2[0].aBeg[0], aPt2[0].aBeg[1])]}
      [path curveToPoint:NSMakePoint(aPt2[k].aEnd[0], aPt2[k].aEnd[1]) controlPoint1:NSMakePoint(aPt2[k].cPt1[0], aPt2[k].cPt1[1]) controlPoint2:NSMakePoint(aPt2[k].cPt2[0], aPt2[k].cPt2[1])]
    }
    [path closePath]
  }
  return MSShapeGroup.shapeWithBezierPath(path);
}

var rd2dec = function(num) {
    return Math.round(num * 100) / 100;
}

var preProcSeg = function(aSegments){
  //normalize to 6.28
  var aSegs = [0]
  var total = 0;
  var n = aSegments.length;
  var i = n;
  while (i--) {total += aSegments[i]}
  var factor = 2 * pi / total
  for (i=1; i<=n; i++) {aSegs.push(aSegs[i-1] + (aSegments[i-1] * factor))}
  aSegs[aSegs.length - 1] = 6.28
  return aSegs
}

var alert = function(sText, sTitle) {
	[[NSApplication sharedApplication] displayDialog:sText withTitle:sTitle];
    //doc.showMessage(sText)
}

var getViewF = function(){
    //get position with view.postion.x etc and size with view.size.width etc.
    view = [doc currentView];
    return [view frame];
}

var styleShape = function(shapeGr, sC){
    var border = shapeGr.style().borders().addNewStylePart();
    border.color = MSColor.colorWithSVGString(sC);
    border.thickness = 2;
    //border.position = 1;
}

var styleShapeArea = function(shapeGr, sC){
    var fill = shapeGr.style().fills().addNewStylePart();
    fill.color = MSColor.colorWithSVGString(sC);
    //var border = shapeGr.style().borders().addNewStylePart();
    //border.color = MSColor.colorWithSVGString("#f0f0f0");
    //border.thickness = 1;
    //border.position = 1;
}

var placeLayer = function(lyr){
    var rL = lyr.rect();
    var v = getViewF();
    var so = [doc scrollOrigin];
    var zv = [doc zoomValue]
    var vX = (v.size.width / 2 - so.x) / zv;
    var vY = (v.size.height / 2 - so.y) / zv;
    rL.origin.x = vX
    rL.origin.y = vY
    lyr.setRect(rL)
    if(sv <= 34400) {
      lyr.resizeRoot(true)
    } else {
      lyr.resizeToFitChildrenWithOption(0)
    }
}

var getRnCol = function(){
  var aCols = ["#B71C1C","#e91e63","#9c27b0","#673ab7","#3f51b5","#2196f3","#0288D1","#00bcd4","#00bcd4","#4caf50","#8bc34a","#cddc39","#F9A825","#FF8F00","#F57C00","#D84315","#795548","#9e9e9e","#607d8b"]
  var lA = aCols.length
  return aCols[Math.floor(Math.random() * aCols.length)]
}

var showDlg = function(sMsg, sInfo, aFields, sBtnGoText){
  var dlg = COSAlertWindow.new();
	dlg.setMessageText(sMsg || "Plugin dialog");
	dlg.setInformativeText(sInfo || "To run this plugin more data will be needed");
  for(var i = 0; i < aFields.length; i++){
    dlg.addTextLabelWithValue(aFields[i].label || ("Field " + i));
  	dlg.addTextFieldWithValue(aFields[i].data  || ("Data " + i));
  }
	dlg.addButtonWithTitle( sBtnGoText || 'OK');
	dlg.addButtonWithTitle('Cancel');

  var aResults = []
	if(dlg.runModal() == 1000) {
    for(var i = 1; i < aFields.length * 2; i+=2) {
      aResults.push(dlg.viewAtIndex(i).stringValue()) //only every other, we don't care about labels
    }
  }
  return aResults
}

var getSkVer = function() {
	var v = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleShortVersionString"]
	var v2 = v.split('.').join("")
	do {
		v2 = v2 + "0"
	} while(v2.length <= 4)
	return (Number(v2) + 0)
}
